정리중이다.
구글 엑셀도 보고 정리하자.
이미지 캡쳐한 프로젝트는 놔두자. 링크를 따로 걸어놓자.
> 추가로 GOF의 원본 그림도 캡쳐해두자.

실제 구현된것을 찾아보자.
  - 자바에서의 인식
  - 웹서버에서의 인식
  - 리액트에서의 인식(프론트엔드)

구현도 어떻게 하는지 알아보자.
  - 요즘은 자바에서는.. 아주 단순하게 가서 필요가 없을지도 모르겠다.
    - 스프링에 거의 녹아 있을것 같다.
    - 백엔드의 관점과 시스템 관리측에서의 관점에서 논해보자.
    - 만들고 싶은것도 논해보자. 

DB와의 연관관계
이론의 알고리즘과의 연관관계(객체(데이터?) 구조, 빅오의 관계)
코딩의 알고리즘과의 연관관계
> 이곳도 엑셀에 어느정도 되어있을것 같은데?

---

1. 개요
> GOF패턴에는 총 23개의 패턴이 있다. GOF를 만든 4명(?)은 왜 3개로 나누었을까? 
> 처음에 나는 GOF패턴끼리 어떻게 다른가를 많이 찾았다. 
> 서로 비슷비슷하다보니 잘 외워지지도 않고 말이다. 이번에 다시 살펴보기 시작하였다. 
> 무엇이든 저자의 의도가 중요하다. 하지만 나의 의도도 중요하다.
> 몬 소리냐고? 저자의 의도가 몬지 모르겠으니 나의 의도대로 한번 살펴보겠다는 것이다. 
> 아직까지 다른 사람들이 본 GOF패턴을 보야야 겠지만 내가 생각한것 부터 정리하고 보도록 하겠다. 

패턴을 가르는 기본 토대는 실생활과 어떤 연관점이 있는가로 두었다.
어떤 책을 보니 건축도 하나의 유기체라고 한다. 
그렇다면 실생활을 기초로 만들어지는 프로그래밍도 하나의 유기체라고 생각된다. 

2. 패턴끼리 상관관계
> 우선은 생성패턴은 모든 패턴의 기초가 되는 것이라고 생각한다. 
> 각 패턴에도 기본이 되는 패턴이 있는데, 
>> 생성패턴에서 제일 기본적인 것은 Factory Method이다. 
>> 구조패턴에서는 Adapter, Bridge, Composite가 기본이 된다.
>> 행동패턴에서는 Strategy가 기본적인 패턴이 되겠다. 

3. GOF 직접 코딩하고 다시정리를 계속 하고 있다. 
> 하면서 느낀것은 이미 우리의 코드에 녹아나 있다는 것이다.
> 어떻게 녹아있는지를 살펴보는것도 재미다.

사이트 : http://www.w3sdesign.com/
> pdf 파일: http://www.w3sdesign.com/GoF_Design_Patterns_Reference0100.pdf
* 개요 : https://jwprogramming.tistory.com/68
* 객체지향과 디자인 패턴 : https://dailyheumsi.tistory.com/148
* 디자인 패턴의 효율성 : https://namu.wiki/w/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4
  - 몇개가 빠져 있다.
* 각분야의 패턴 언어 : https://ko.wikipedia.org/wiki/%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4
* 소프트웨어 디자인 패턴 : https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4  
* j2ee 패턴 : http://www.corej2eepatterns.com/
  - 웹서버를 위한 패턴

# 생성패턴 5, 기존것으로 새로운 클래스 생성법 
Factory Method : 하나의 object가 완제품인 경우 완제품을 만들수 있는 여러가지 방법
Abstract Factory : 여러개의 object가 반제품을 거쳐서 여러개의 완제품으로 만들어 지는 방법 
Builder : 조립, 조립 클래스 만들기
Prototype : 복사, 기존관계와 상관없는 클래스 생성 
Singleton : 유일, 전체 공유사용, 글로벌 변수
# 구조패턴 7, 생성된 object 사용방법, 데이터, 정적구조,제약사항
Adapter : 각색가, 번안자(번역:외국책을 우리나라글자로 만들기), 편곡자, 인터페이스 재조정
Facade : 정면, 대표, 사용하기 편하게 만들기
Decorator : 꾸미기, 기능을 하나씩 더 추가할수 있는 구조만들기
Bridge : 연결, 접목시켜서 새로운 구조 만들기
Composite : 합성, 트리구조
Flyweight : 공유
Proxy : 대리(대신하는)
# 행동패턴 11, 코드, 동적구조, 실행상태,상태관리(state)
Strategy : 전략, 바꿔쓰기
Template Method : 주형(거푸집) 방식
Iterator : 반복자
State : 상태
Mediator : 중재인, 모아 놓기
Memento : 기념물, 원복하기
Command : 명령, 이벤트 처리
Visitor : 방문자, 처리자를 따로 만든다.
Chain of Responsibility : 책임사슬, 처리할 곳을 찾아서 처리한다. 
Observer : 관찰, 등록후 나중에 실행
Interpreter : 번역기, parsing

2020.10 다시 써본다.
> 이 관점은 설계를 위한 관점에서 봤을때 3개로 나뉜것으로 보인다.
> 패턴이란 것을 구지 쓰는 이유는 원활한 커뮤니케이션을 위한 관점 통일이 아닐까? 
> 코드를 위한 구조는... javapattern쪽에 되어 있는것 같다.
> 이과정에에 있는 객체 지향은 기본으로 알고이써야하는 것이다. 

---

* [코드참조](http://www.w3sdesign.com/GoF_Design_Patterns_Reference0100.pdf)
* [UML 참조](http://vincehuston.org/dp/all_uml.html)

리팩토링(코딩을 위한) 디자인패턴

	1. 인터페이스 사용
		- Strategy는 로직 분리
			- State는 스위칭
			- Bridge는 로직의 분할
		- Template Method는 
			- 인터페이스가 아닌 추상클래스를 사용하는 방법
			- 로직을 뼈대를 만들고 상세로직은 다른 클래스에서 진행하는 방식으로 abstract으로 구현해야한다.	
	2. recursive 반복
		- 반복을 위해서는 List가 필요하다. 객체를 모은다.
		- Composite는 트리구조
			- Interpreter는 List에 담겨 있는 데이터의 검색/분석으로 많이 쓰인다.
			- Decorator은 값을 추가하기 위한 것이고
			- Chain Of Responseibility는 분업, 처리할수 있으면 하지만 아니면 다음것으로 넘기는 것
		- Flyweight는 Composite와 비슷하게 객체를 담지만, pool구조
	3. ETC(로직 분할의 처리)
		- Mediator은 비슷한 행동에 대해서 처리방식을 하나의 클래스에 모아두는 방식이다. 
		- Observer는 등록된 객체를 한꺼번에 업데이트 하는 방식이다.
		- Visitor는 유형별로 처리방식 정의, 방문객에 대한 처리로직을 모두 정의해 놓는다.		
	4. 대신 처리(클래스 재사용)
		- Facade는 기존에 있는것들을 하나의 메서드에서 불러와서 처리하도록 한다.
		- Adapter는 기존것의 인터페이스명(or param) 변경
		- Proxy는 우선은 내가 처리할수 있는곳까지 처리하고 최종적으로는 예전객체를 호출해서 한다.
	5. UI
		- Command는 이벤트에 대한 처리방식
		- Memento는 복구방법
		- Iterator로 반복할때 임시저장을 위해서 Memonto를 쓸수도 있다고 이야기 한다.
			> UML은 이해가 잘 안된다.
	6. 생성패턴
		- Builder는 복합객체만들기, 요소별로 정의해서 조립하여서 내놓는 것
		- AbstractFactory은 제품군별로 객체만드는 것을 정의해 놓은 것
		- FactoryMethod는 다른 클래스의 메서드에서 객체를 생성하도록 하는 것
		- ProtoType은 복제이다. 현재 있는것을 복제하여서 하는것. 디자인패턴에 있는 uml은 잘 이해가 안된다.
		- Singleton은 객체의 공유를 위해서 유일하게 만드는 방식이다.
	7. 패턴 공부의 유용성	
		- 객체에서 사용할 일반적인 방법을 정의
		- UML에 대해서 예시를 알수가 있다.
		- 언어에 대한 패턴 기준을 정할수 있다.
		- 설계할때 아 이건 이런 패턴을 쓰자고 해서 공부했는데.. 이건모 그렇게 쓸정도는 아닌것 같다. 구현을 위해서 쓰는것이랄까나?

---

그들이 나누었을 대화내용 추정을 해보자. 나름 재미나는데.. 일관성이 없는것 같기도 하다.

---

1. 설계관점에서의 디자인패턴
    - 데이터 설계와 비슷하면서도 다른 객체지향 설계
    - DDD와 연계된다. 
2. UI에서의 디자인 패턴
3. 백엔드에서의 디자인패턴
4. 프론트 엔드에서의 디자인 패턴
    - 디자인패턴은 어떻게 보면 백엔드 관점에서 나온것이 많다.

사이드로 
1. 객체지향에 대한것
2. 객체지향 원리에 대한 것을 파고 가야한다.
3. 기타 : 알고리즘도 포함이 될까?

이모든것은 개발자간의 원활한 커뮤니케이션을 위한것이라고 생각하자.
    - 꼭 해야하는 것은 아니지만.. 꼭 하고 있지는 않지만...

기타
1. 알고리즘
2. 데이터 구조

3. 디버깅
4. 문서(API등등)
5. 모니터링
6. 컴퓨터 개론


---
다시 정리하는 디자인 패턴
> GOF의 디자인패턴은 기본적은 object는 이미 나왔다는 전재하에 만드는 것같다. 

# 생성패턴 5, object(class), object 생성법
> 생성된 object를 재조립하여서 새로운 object를 만드는 방법 
 
Factory Method : 하나의 object가 완제품인 경우 완제품을 만들수 있는 여러가지 방법
Abstract Factory : 여러개의 object가 반제품을 거쳐서 여러개의 완제품으로 만들어 지는 방법 
Builder : 조립하는 방법
  - 특정 object를 사용하는 방법을 통일한다.
Prototype : 사용하고 있는 object 데이터(상태)를 그대로 가져오는 복제 방법, deep copy이다. 관계성은 지워버린다.
    - .clone()로 보통 많이 쓴다.
Singleton : 공유해야하는 object, 1개밖에 없는 object 사용방법
> 전체 변수가 한두개가 아니다. scope에 따라서 10개가 넘을 때도 있다.
>> OS 변수, 시스템 변수, 시스템 환경변수, 서버(시스템) 변수, (시스템)프로퍼티, 메모리 변수, 세션 변수, 객체 변수, 클라이언트 변수(쿠키)
>>> 전체변수를 어디까지 두느냐에 따라서 시스템이 많이 달라진다.
>>> 어디서 로딩되냐에 따라서 달라진다. 보통은 시스템이 시작될때 모두 올라온다.
>>> 너무 양이 많으면 시스템이 무거워지고, 수정에 너무 많이 투자하게 된다. 
>>> 의존성이 너무 강해지게 된다.

** 그러고보니 엑셀에도 정리해놓은게 있었네... 구글엑셀을 뒤져보자.

* object의 구조를 봐야한다. 
    - 1개로 되어있는가? 여러 개의 object로 구성되는 object인가?
    - 공유할수 있는 과정이 있는가? 
    - 과정이 변하는가? 과정이 아닌 구조가 변하는 가?
        - 변하지 않는 구조는 고유의 속성이다.
    - 다른 object들에서 공유해야하는 object인가?

* singleton을 활용하여서 새로운 구조은 object pull구조를 만들수도 있다.
    - 새로 생성하는 것보다는 나으므로...
    
    
# 구조패턴 7, 생성된 object 사용방법, 데이터, 정적구조,제약사항
Adapter : 기존 것을 재사용, 인터페이스 재조정
Facade : 정면,대표로 내세우기, 
  - 복잡한 구조를 알기 쉽게 보여주는 구조
Decorator : 기능을 하나씩 더 추가할수 있는 구조만들기, 여러개의 객체로 나누어서 반복처리
  - 리액트의 HOC(Higher-Order Components)를 떠오르게 만든다.
  - 객체 자체를 넘겨서 처리하게 만든다.
  - 객체를 반복적으로 처리하게 만드는 구조(계속된 덧붙임)
Bridge : 접목시키기
  - 객체를 가져와서 새로운 구조로 만들기
Composite : 트리구조(재귀를 사용)
Flyweight : 객체 미리 만들어서 공유하여 사용, 예제로 하는게 제일 알기 쉬울것 같다.
  - 작게는 shallow copy(얕은복사)들 들수 있겠다. 주소값으로 공유하는 것
    - `const a = 1; const b =a;` : 이것은 b의 값을 바꾸면 a값도 바뀌게 된다.
        - 음... 기본 value가 아니라 object를 할떄만 일수도 있다.
  > shallow copy때문에 골치가 아프다.. 
  >> 기본적으로 shallw copy를 많이 쓰기때문에 신경쓰지 않으면 내가 원하던 값이 아니라 변경된값으로 모두 바뀌어 있기 때문이다.        
  - 각종 pool들 : 스프링의 코어인 객체 pool, DB pool  
Proxy : 핵심기능은 기존에것에서 처리하게하고, 필요 없는 기능을 proxy라는 곳으로 만들어서 사용하는 방법
  - AOP(관점 지향 프로그래밍)의 기본 사상이라고 할수 있다.
    - 개인적으로 만들어야 할것들 : 코드를 바탕으로 문서 만들기, Java Doc, API문서, 다국어처리 
  - Dynamic Import
  - 대표적으로 로그를 따로 나오게 하는 것
  - 테스트케이스 검사를 따로 하는 것
  - 작게는 클래스를 동적으로 가져와서 사용하는 방법에서 기능일부를 타시스템에서 전달시키는 방법도 있다. 

# 행동패턴 11, 코드, 동적구조
## 상태관리 : 실행상태, 상태관리
State : 상태에 따른 처리
Memento : 원복
  - Memento mori, 자신의 죽음을 기억하라.
## 특이구조
Strategy : 하나의 구조에서 다른 상태를 만드는 방법, 
  - 인터페이스를 정하고 구현
  - 하나의 인터페이스, 여러개의 구현 방법
Template Method : 공통으로 관리되는 소스 구현
  - 추상 클래스
Iterator : 리스트 처리(for문 방식)
Interpreter : 번역기, 파싱을 위한 방법
  - sql파싱기, 단어 분석, 분석기
Mediator : 중재자, 모든 기능을 한군데로 몰아 넣는다.
Command : 이벤트 처리방법, 클릭등의 행동이 들어오면 하는것
  - 대표적으로 메뉴구조가 있다.
Chain of Responsibility : 책임사슬, 처리할 곳을 찾아서 처리한다. 
  - 처리할곳을 다 넘겨준뒤에 처리하면 그곳에서 멈춘다.
  - 순환구조 
Visitor : 처리자를 따로 만들어 놓고, 처리자를 지정하여서 특정 처리자에게 처리하도록 한다.
Observer : 관찰대상을 등후에 특정 시점에 실행시킨다.


  